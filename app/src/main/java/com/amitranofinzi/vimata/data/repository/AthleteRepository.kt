package com.amitranofinzi.vimata.data.repository

import android.util.Log
import com.amitranofinzi.vimata.data.model.Chat
import com.amitranofinzi.vimata.data.model.Relationship
import com.amitranofinzi.vimata.data.model.User
import com.amitranofinzi.vimata.data.model.Workout
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.tasks.await
import java.net.HttpURLConnection
import java.net.URL

class AthleteRepository(
) {
    private val firebaseAuth: FirebaseAuth = FirebaseAuth.getInstance()
    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance()

    //gets list of all trainers for a given athleteID
    suspend fun getTrainerIdsForAthlete(athleteID: String): List<String> {
        val snapshot = firestore.collection("relationships")
            .whereEqualTo("athleteID", athleteID)
            .get()
            .await()

        return snapshot.documents.mapNotNull { it.getString("trainerID") }
    }

    //get trainers as a list of User
    suspend fun getTrainers(trainerIds: List<String>): List<User> {
        if (trainerIds.isEmpty()) {
            Log.d("AthleteRepository", "Empty athleteIds list")
            return emptyList()
        }
        try {
            //Query firestore database in order to find all the users with uid equal to a value in AthleteIds
            val snapshot = firestore.collection("users")
                .whereIn("uid", trainerIds)
                .get()
                .await()
            Log.d("AthleteRepository", "Fetched documents: ${snapshot.documents.map { it.id }}")
            val trainers = snapshot.documents.mapNotNull { document ->
                try {
                    Log.d("AthleteRepository", "Document data: ${document.data}")
                    val trainer = document.toObject(User::class.java)
                    if (trainer!= null) {
                        Log.d("AthleteRepository", "User found: $trainer")
                    } else {
                        Log.d("AthleteRepository", "Document ${document.id} could not be converted to User")
                    }
                    trainer
                } catch (e: Exception) {
                    Log.e("AthleteRepository", "Error converting document to User: ${document.id}", e)
                    null
                }
            }
            return trainers
        } catch (e: Exception) {
            return emptyList()
        }
    }

    suspend fun getAthletesWorkouts(athleteID: String) : List<Workout> {
        val snapshot = firestore.collection("workouts")
            .whereEqualTo("athleteID", athleteID)
            .get()
            .await()
        return snapshot.documents.mapNotNull { document->
            document.toObject(Workout::class.java)
        }
    }

    suspend fun getWorkoutPdf(workoutId: String): ByteArray? {
        val document = firestore.collection("workouts")
            .document(workoutId)
            .get()
            .await()

        return document.get("pdfUrl")?.let { pdfUrl ->

            try {
                val url = URL(pdfUrl as String)
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "GET"
                connection.connect()

                if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                    val inputStream = connection.inputStream
                    return@let inputStream.readBytes()
                } else {
                    Log.e("AthleteRepository", "Failed to load PDF. Response code: ${connection.responseCode}")
                    null
                }
            } catch (e: Exception) {
                Log.e("AthleteRepository", "Error loading PDF", e)
                null
            }
        }
    }

    //get trainers email
    suspend fun getUserByEmail(email: String): User? {
        try {
            val snapshot = firestore.collection("users")
                .whereEqualTo("email", email)
                .limit(1) // Limitiamo la query a 1, anche se in teoria dovrebbe esserci solo un documento con quella email
                .get()
                .await()

            return snapshot.documents
                .firstOrNull()
                ?.toObject(User::class.java)
                //?.copy(uid = snapshot.documents[0].id)

        } catch (e: Exception) {
            Log.e("AthleteRepository", "Error getting user by email: $email", e)
            return null
        }
    }


    suspend fun addTrainerRelationship(trainerId: String?, currentUserId: String): String? {
        Log.d("AddTrainer", "${trainerId} ${currentUserId}")
        try {
            val relationship = Relationship(
                id = "", // generated by firestore
                athleteID = currentUserId,
                trainerID = trainerId
            )
            //adddocument to firestore
            Log.d("AthleteReference",relationship.toString())
            val relationshipReference= firestore.collection("relationships")
                .add(relationship)
                .await()

            Log.d("AthleteReference",relationshipReference.toString())

            //generated id
            val generatedId = relationshipReference.id

            Log.d("AthleteReference",generatedId)
            val document = firestore.collection("relationships").document(generatedId)
            Log.d("AthleteDocument", document.toString())
            document.update("id", generatedId).await()
            Log.d("AthleteDocument", relationship.toString())

            return firestore.collection("relationships").document(generatedId).get().await().toObject(Relationship::class.java)!!.id
        } catch (e: Exception) {
            Log.e("AthleteRepository", "Error adding relationship", e)
            return null
        }
    }

    suspend fun startNewChat(email: String, currentUserId: String) {
        try {
            // Find the trainer by email to get trainerId
            val trainer = getUserByEmail(email)
            if (trainer == null) {
                Log.e("AthleteRepository", "Trainer with email $email not found")
                return
            }
            // Add trainer relationship
            val relationshipId = addTrainerRelationship(trainer.uid, currentUserId)

            // Create a new Chat object
            if (relationshipId == null) {
                Log.e("AthleteRepository", "Relationship between athlete and trainer not found")
                return
            }
            val newChat = Chat(
                chatId = "",
                relationshipID = relationshipId,
                lastMessage = "New Chat Started"
            )
            //Add the Chat object to Firestore
            val chatReference = firestore.collection("chats")
                .add(newChat)
                .await()

            //update id generated
            val generatedId = chatReference.id
            val  document = firestore.collection("chats").document(generatedId)
            Log.d("CreationChat", document.toString())
            document.update("chatId", generatedId)
                .await()
            Log.d("AthleteRepository", "New chat started successfully")
        } catch (e: Exception) {
            Log.e("AthleteRepository", "Error starting new chat", e)
            // Handle error, possibly show error message to UI
        }
    }

}
